

# This file was *autogenerated* from the file ./proper.sage
from sage.all_cmdline import *   # import sage library

_sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_12 = Integer(12); _sage_const_20 = Integer(20); _sage_const_36 = Integer(36); _sage_const_63 = Integer(63); _sage_const_120 = Integer(120); _sage_const_9 = Integer(9); _sage_const_24 = Integer(24); _sage_const_5 = Integer(5); _sage_const_15 = Integer(15); _sage_const_60 = Integer(60); _sage_const_5000 = Integer(5000)#!/usr/bin/env sage
import argparse
import functools
import pathlib
import random
import sys

from tqdm import tqdm
from tqdm.contrib.concurrent import process_map


# Finite families of the finite irreducible Coxeter groups.
TYPES = [
  ['E', _sage_const_6 ],
  ['E', _sage_const_7 ],
  ['E', _sage_const_8 ],
  ['F', _sage_const_4 ],
  ['G', _sage_const_2 ],
  ['H', _sage_const_3 ],
  ['H', _sage_const_4 ]
]


def maxw0(W, w):
  '''
  returns maxw_0(W, w) for finite irreducible Coxeter groups.

  W is a Coxeter group.
  w is an element of W.
  '''
  n = W.rank()
  dw = len(w.descents(side='left'))
  t = W.coxeter_type().type()

  if   t == 'A': return binomial(dw+_sage_const_1 , _sage_const_2 )
  elif t == 'B': return dw**_sage_const_2 
  elif t == 'D': return dw**_sage_const_2 -dw if dw > _sage_const_3  else binomial(dw+_sage_const_1 , _sage_const_2 )
  elif t == 'E': return [_sage_const_0 ,_sage_const_1 ,_sage_const_3 ,_sage_const_6 ,_sage_const_12 ,_sage_const_20 ,_sage_const_36 ,_sage_const_63 ,_sage_const_120 ][dw]
  elif t == 'F': return [_sage_const_0 ,_sage_const_1 ,_sage_const_4 ,_sage_const_9 ,_sage_const_24 ][dw]
  elif t == 'G': return [_sage_const_0 ,_sage_const_1 ,_sage_const_6 ][dw]
  elif t == 'H': return [_sage_const_0 ,_sage_const_1 ,_sage_const_5 ,_sage_const_15 ,_sage_const_60 ][dw]
  elif t == 'I': return n if dw == _sage_const_2  else dw
  else: raise NotImplementedError('no formula known for type ' + t)


def proper(W, w):
  '''
  returns True if w is proper in W; false otherwise

  W is a Coxeter group.
  w is an element of W.
  '''
  n = W.rank()
  return w.length() <= n + maxw0(W, w)


def reduced_word(w, latex):
  '''
  returns the reduced word of w.

  w is an element of a Coxeter group.
  if latex is True, it will print the word in math LaTex format.
  '''
  rw = w.reduced_word()
  return (
    ''.join(['s_{'+str(s)+'} ' for s in rw])
    if latex else
    ''.join([str(s) for s in rw])
  )


def action(W, latex, w):
  if not proper(W, w): return None
  return reduced_word(w, latex=latex)


def handle_chunk(W, latex, num_processes, length):
  chunk = list(W.elements_of_length(length))
  rws = process_map(
    functools.partial(action, W, latex),
    chunk,
    max_workers=num_processes,
    chunksize=_sage_const_5000 ,
    desc=f'l={length}',
  )
  return rws


def main(args):
  print('creating group ...')
  W = CoxeterGroup([args.type, args.n], implementation='permutation')
  len_w0 = W.long_element().length()

  print('shuffling')
  lengths = list(range(len_w0+_sage_const_1 ))
  random.shuffle(lengths)

  print('chunking ...')
  rws_chunks = process_map(
    functools.partial(handle_chunk, W, args.latex, args.num_processes),
    lengths,
    max_workers=args.num_processes,
    chunksize=(len_w0+_sage_const_1 ) // args.num_processes,
    desc='chunker',
  )

  print('filtering ...')
  rws = [
    rw
    for rws in rws_chunks
    for rw in rws
    if rw is not None
  ]

  print('sorting ...')
  rws.sort(key=lambda rw: (len(rw), rw))

  print('writing to file ...')
  with args.file.open('w') as f:
    for rw in rws:
      f.write(rw)
      f.write('\n')

  print('done!')


if __name__ == '__main__':
  parser = argparse.ArgumentParser(
    'List proper Coxeter group elements for finite families.'
  )
  parser.add_argument(
    '--type', type=str, required=True, help='Coxeter Type',
  )
  parser.add_argument(
    '--file', type=pathlib.Path, required=True, help='File to store results',
  )
  parser.add_argument(
    '--num-processes', type=int, default=_sage_const_1 , help='File to store results',
  )
  parser.add_argument(
    '-n', type=int, required=True, help='n',
  )
  parser.add_argument(
    '--latex', action='store_true', help='enables latex pretty printing',
  )
  args = parser.parse_args()
  main(args)

